\section{Related Work}
\label{sec:relatedWork}

%\input{08tableRelatedWork}

To the best of our knowledge, eBPFlow is the first packet processing hardware device that is Turing-Complete, enables the programming of stateful and stateless network functions, and can dynamically modify the parser, matching, and actions at zero downtime.
%and can also self-populate its tables.

%OpenFlow standard 
\textbf{OpenFlow standard}. The OpenFlow~\cite{McKeown:2008:OpenFlow} standard, although being the most adopted SDN architecture, has limitations. Its matching structure is unable to do inequality, complement (not operation), or range matching. 
%OpenFlow does not support self-populating the tables. It delegates the responsibility entirely to the controller.


% P4, C, Domino
%todo: C?
\textbf{High level domain specific languages.} The P4 programming language P4~\cite{Bosshart:2014:P4} adopts the match-action abstraction model. 
%does not have yet support for programs that self-populate the tables. It might be a possible future improvement, which is currently limiting the design of new data plane functionalities.
P4 language can be used to generate eBPF instructions using the compiler from P4 to eBPF~\cite{P42EBPF2015}. Domino~\cite{Sivaraman:2016:PTH:2934872.2934900} is a high-level language that can be compiled into Banzai, which is a low-level machine model designed for line-rate switches. 
Although P4 and Domino include small and fast registers to store state, they provide a restricted functionally for large range of stateful functions.

%- POF, NetASM
\textbf{Intermediate level domain specific languages.} Some works(~\cite{Song:2013:POF:2491185.2491190,Shahbaz:2015:NetASM,Sivaraman:2016:PTH:2934872.2934900}) define an intermediate instruction set to improve the data plane programmability.
Protocol Oblivious Forwarding (POF)~\cite{Song:2013:POF:2491185.2491190} from Huawei describes a protocol-independent programmable SDN switch. POF defines a generic flow instruction set (FIS) to search and extract keys from the header fields and also modifying packets and updating match tables. NetASM~\cite{Shahbaz:2015:NetASM} defines an instruction set with 23 instructions and provides an intermediate representation for programmable data planes. It can be used as the target language for virtual switches and line-rate switches. 

% DPDK, NetMap
\textbf{Packet I/O.}   Data Plane Development Kit (DPDK) framework~\cite{DPDK2018} is a set of packet I/O libraries that consumes CPU cores for fast packet processing. 
eXpress Data Path (XDP)~\cite{Hoiland-Jorgensen:2018:EDP:3281411.3281443} is a kernel hook for fast software packet processing, allowing to execute BFP programs inside the Linux kernel.
Following the same direction, NetMap~\cite{rizzo2012netmap} is an API that enhances access to network packets by user space applications.
%Those solutions are not transparent, thus requiring from the network programmer knowledge about the implementation details. 


% OvS, Pisces
\textbf{Software switches.} PISCES~\cite{Shahbaz:2016:Pisces} is a software switch based on OpenVSwitch (OVS)~\cite{Pfaff:2015:OpenVSwitch} that supports the high-level language P4. 
%P4 is used to define the prototype data plane. 
PISCES switch is a modified version of OVS with parsing, matching, and actions generated by the P4 compiler. 
PISCES can express conditionals (and) and relational tests ($>,<$) comparison of header fields.
%PISCES project is not designed to run on hardware.
%PISCES é voltado para processamento de pacotes em software para em centros de dados.
PISCES generated code must be recompiled for each modification in the P4 program. Click~\cite{kohler2000click} is a modular software router architecture that has been used in different experimental router designs.
%O protótipo foi validado comparando a complexidade do desenvolvimento e desempenho em encaminhar pacotes baseado no OpenvSwitch.

% PISCES workflow:
%
%"The workflow is as follows:  First, the programmer creates a P4 program and uses the PISCES P4 compiler to generate new parse, match and action code for OVS. Second, OVS is compiled (using the regular C compiler) to create a protocol-dependent switch that processes packets as described in the P4 program. To modify a protocol, a user modifies the P4 program which compiles to a new hypervisor switch binary."

%- FlexPipe, RMT, dRMT
\textbf{Multi-stage match-action.} RMT~\cite{bosshart2013forwarding}, dRMT~\cite{chole2017drmt}, and FlexPipe~\cite{FlexPipe2012} are reconfigurable chips that follows a match-action processing model.
RMT~\cite{bosshart2013forwarding} and its latest version dRMT~\cite{chole2017drmt} provides an architecture that allows reconfigurable matching tables for multi-stage packet processors implemented in ASIC that provides certain programmability and can process the packets in the input rate of the network interfaces. RMT can not execute regular expressions when parsing nor manipulate packet payload. Intel's FlexPipe~\cite{FlexPipe2012} is a switch chip architecture that provides an architecture with 32 stages match-action pipeline that is programmable through a dedicated microcode. But their programmability is not straightforward. Tofino~\cite{barefoot-tofino} from Barefoot and Xpliant~\cite{cavium1,cavium2} from Cavium are commercial products that offer high speed (Tbit/s) programmability probably using a pipelined approach.
PLUG (Pipelined Lookup Grid)~\cite{DeCarli:2009:PFL:1592568.1592593} also proposed a hardware to speed up the deployment of new protocols. But, PLUG focuses on a flexible lookup module, disregarding dynamic parsing and actions. 




%- BPFabric, IOVisor
\textbf{BPF related} BPFabric~\cite{Jouet:2017:BPFabric} was proposed as a platform in software that allows protocol-independent packet processing. 
BPFabric uses eBPF instructions to define how packet processing and forwarding in the data plane are performed.
BPFabric was, initially, implemented over a Linux raw socket interface and, later, adapted over the DPDK.
It might be the case that tenants of datacenters would require their rented CPU cores used for processing instead of packet forwarding. Moreover, currently BPFabric does not incorporate longest prefix match, necessary for routing. Finally, BPFabric does not take advantage of specialized  hardware modules such as TCAMs and CAMs.
As stated by the author~\cite{Jouet2017Thesis}, the high cost of table operations is to be expected in a software switch implementation
since no optimized memory hardware is available. 
%Since this is a very relevant topic, while developing this project, Jouet~\cite{Jouet2017Thesis} proposes a single stage eBPF processor with Altera FPGA platform. But, the proposed processor does not have pipeline stages, the project was not ported to NetFPGA platform, or integrated or tested at a network element. 
There  are  already some emerging eBPF projects inspired by IOVisor~\cite{IOvisor} project.
InKev~\cite{InKeV2016} enables to execute eBPF programs on the datapath for virtual networks, targeting data center networks.
Tu et al.~\cite{Tu:2017:BEO:3139645.3139657} describe the design, implementation, and evaluation of an eBPF-based extensible datapath for OVS.
To enable OpenFlow to parse arbitrary field, Jouet et al. defined an OpenFlow Extended match filed (OXM) to install BPF bytecode and added a libpcap engine to Openflow software switch to execute the bytecode~\cite{Jouet2015OpenFlow}.

% P4FPGA, opensketch, OpenFlow NetFPGA

\textbf{FPGA related} P4FPGA~\cite{p4fpga} is a platform developed in hardware that performs conversion of P4 programs to Verilog.
%P4FPGA was instrumented on the FPGA Xilinx Virtex-7 XC7V690T.
The three main components of the platform are: code generator, runtime system, and the optimizer. The code generator has the capability of producing a packet processing pipeline. The runtime system provides a hardware abstraction layer for basic functionalities including memory management, transceiver management, and control/host communication. The optimizer is used to provide parallelism in the hardware by increasing the throughput and decreasing latency.
P4-To-VHDL~\cite{BENACEK201822} is a tool that converts a P4 description to a synthesizable VHDL code suitable for the FPGA implementation.
%P4FPGA can not modify the parser, matching or actions at run time.
OpenSketch~\cite{Yu:2013:SDT:2482626.2482631} also utilized NetFPGA for prototyping. They implemented a three-stage pipeline (hashing, filtering, and counting) at the data plane for network traffic measurement. Naous et al.~\cite{Naous:2008:IOS:1477942.1477944} describe the implementation of an OpenFlow Switch on the NetFPGA 1G platform. 
FlowBaze~\cite{FlowBlaze2019} is an FPGA-based SmartNIC that allows stateful packet processing in hardware by programming using Extended Finite State Machines (EFSM). It is not Turing-complete and to change the parser, match fields, or EFSM transition tables, it requires a new synthesis.
% KeyFlow
\textbf{Arithmetic Switch.} KeyFlow~\cite{Martinello2014KeyFlow}
%is a system that describes a new approach to switching packets. 
%The KeyFlow 
 switch commutes packets based on mod operation.
Packets receive a label based on the Chinese Remainder Theorem.
KeyFlow is complementary to our system because it could be implemented in our system, which already has the eBPF processor that executes the mod instruction in hardware. 

%, SoftNIC.
\textbf{Smart NIC} 
SoftNIC~\cite{Han:EECS-2015-155} provides a programmable NIC interface with Click~\cite{Kohler:2000:CMR:354871.354874}. It is a different approach to provide network programmability. It provides new functionalities for host NIC through software.
Netronome~\cite{Netronome2018} provides a SmartNIC that can be programmed with eBPF instructions. This shows the trend that eBPF is also being adopted by industry. 
Netronome SmartNIC focuses on the L2-layer, having at most two ports, and does not provide specialized hardware modules for higher layer such as TCAMs.
Netronome SmartNIC expressiveness can be categorized as eBPF-verifier since it needs to run the verifier and can not have backward jumps. It requires loop unrolling, which increases the number of instructions. For example, it could not fit the ChaCha20 network function. 

% NPU, Xpliant, Tofino
\textbf{Network processing units (NPUs).} NPUs~\cite{Sherwood:2003:PMA:859618.859652,Keslassy:2012:PPG:2428663.2428680} 
and multi-core software routers~\cite{Dobrescu:2009:REP:1629575.1629578} are widely used in industry with several commercial products~\cite{intel, cisco, micro, mellanox}. They are basically a shared-memory multi-core processor.  NPUs are slower than regular switches and present non-deterministic performance due to issues such as cache misses and pipeline flushes. 


% Table~\ref{tab:05related_work} compares some of the related work platforms, describing: work description, year of publication, which high-level language it uses, whether it was implemented in hardware or software, which model was used, and whether a new installation can be done at runtime with zero downtime.

\textbf{WSN.} The idea to use a virtual machine to reprogram the network~\cite{Paek:2010:TAT:1777406.1777413,Levis:2002:MTV:635508.605407}
 is common in Wireless Sensor Networks (WSNs) since the network is physically unreachable.


